
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="Anhang_Literatur.html">
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.0, mkdocs-material-9.5.25">
    
    
      
        <title>Anhang: Quelltext - Flüchtig, Anonym & Digital</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.6543a935.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#quelltext" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="index.html" title="Flüchtig, Anonym &amp; Digital" class="md-header__button md-logo" aria-label="Flüchtig, Anonym & Digital" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Flüchtig, Anonym & Digital
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Anhang: Quelltext
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var media,input,key,value,palette=__md_get("__palette");if(palette&&palette.color){"(prefers-color-scheme)"===palette.color.media&&(media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']"),palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent"));for([key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="index.html" title="Flüchtig, Anonym &amp; Digital" class="md-nav__button md-logo" aria-label="Flüchtig, Anonym & Digital" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    Flüchtig, Anonym & Digital
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="index.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Einleitung
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="Kapitel_1.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    1. Digital History und Wikipedistik – Diskurse und Fehlstellen
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="Kapitel_2.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    2. Ansätze einer digitalen Quellenkritik
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="Kapitel_3.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    3. Fallbeispiel: 1989 Tiananmen Square protests
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="Kapitel_4.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    4. Fazit und Ausblick
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="Anhang_Literatur.html" class="md-nav__link">
        
  
  <span class="md-ellipsis">
    Anhang: Literatur
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Anhang: Quelltext
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="Anhang_Quelltext.html" class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Anhang: Quelltext
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#python-skripte" class="md-nav__link">
    <span class="md-ellipsis">
      Python Skripte
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python Skripte">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#class-usernetwork" class="md-nav__link">
    <span class="md-ellipsis">
      class UserNetwork
    </span>
  </a>
  
    <nav class="md-nav" aria-label="class UserNetwork">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#def-_get_xml_dataself-url-stylesheet" class="md-nav__link">
    <span class="md-ellipsis">
      def _get_xml_data(self, url, stylesheet)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-add_article_dataself-url" class="md-nav__link">
    <span class="md-ellipsis">
      def add_article_data(self, url)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-compute_languageself" class="md-nav__link">
    <span class="md-ellipsis">
      def compute_language(self)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-add_usercontributionsself-depth-100-offset-users-none" class="md-nav__link">
    <span class="md-ellipsis">
      def add_usercontributions(self, depth = "100", offset = "", users = None)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-delete_nodes_by_countself-edgecount-2-user-false" class="md-nav__link">
    <span class="md-ellipsis">
      def delete_nodes_by_count(self, edgeCount = 2, user = False)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-return_intervalself-begin-end" class="md-nav__link">
    <span class="md-ellipsis">
      def return_interval(self, begin, end)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xslt-schemata" class="md-nav__link">
    <span class="md-ellipsis">
      XSLT-SCHEMATA
    </span>
  </a>
  
    <nav class="md-nav" aria-label="XSLT-SCHEMATA">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#historyxsl" class="md-nav__link">
    <span class="md-ellipsis">
      history.xsl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#userxsl" class="md-nav__link">
    <span class="md-ellipsis">
      user.xsl
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#python-skripte" class="md-nav__link">
    <span class="md-ellipsis">
      Python Skripte
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Python Skripte">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#class-usernetwork" class="md-nav__link">
    <span class="md-ellipsis">
      class UserNetwork
    </span>
  </a>
  
    <nav class="md-nav" aria-label="class UserNetwork">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#def-_get_xml_dataself-url-stylesheet" class="md-nav__link">
    <span class="md-ellipsis">
      def _get_xml_data(self, url, stylesheet)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-add_article_dataself-url" class="md-nav__link">
    <span class="md-ellipsis">
      def add_article_data(self, url)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-compute_languageself" class="md-nav__link">
    <span class="md-ellipsis">
      def compute_language(self)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-add_usercontributionsself-depth-100-offset-users-none" class="md-nav__link">
    <span class="md-ellipsis">
      def add_usercontributions(self, depth = "100", offset = "", users = None)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-delete_nodes_by_countself-edgecount-2-user-false" class="md-nav__link">
    <span class="md-ellipsis">
      def delete_nodes_by_count(self, edgeCount = 2, user = False)
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#def-return_intervalself-begin-end" class="md-nav__link">
    <span class="md-ellipsis">
      def return_interval(self, begin, end)
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#xslt-schemata" class="md-nav__link">
    <span class="md-ellipsis">
      XSLT-SCHEMATA
    </span>
  </a>
  
    <nav class="md-nav" aria-label="XSLT-SCHEMATA">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#historyxsl" class="md-nav__link">
    <span class="md-ellipsis">
      history.xsl
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#userxsl" class="md-nav__link">
    <span class="md-ellipsis">
      user.xsl
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="quelltext">Quelltext</h1>
<h2 id="python-skripte">Python Skripte</h2>
<p>Im Folgenden werden Auszüge des für diese Untersuchungen geschriebenen Quelltextes aufgelistet. Die Auswahl beschränkt sich dabei auf zentrale Bestandteile der Funktionslogik. Ausschließlich unterstützende Teile wie Konstruktoren oder getter und setter werden nicht aufgeführt. Der vollständige Quelltext liegt liegt als usernetwork.py der Arbeit bei. Der Quelltext wurde in Python 3.6 unter Verwendung von Spyder 3.2.6 geschrieben.</p>
<h3 id="class-usernetwork">class UserNetwork</h3>
<p>Klasse zur Datenerhebung- und -verarbeitung von Usernetzwerken in der Wikipedia. Dient als Grundlage für Netzwerkvisualisierungen und -analysen.</p>
<pre><code class="language-python"># Exemplarischer Aufruf:
# Initialisierung und Abruf der letzten 500 Versionen einer Artikelhistorie:
usrntwrk = UserNetwork()
usrntwrk.add_article_data(&quot;https://en.wikipedia.org/w/index.php?title=Coronavirus_disease_2019&amp;offset=&amp;limit=500&amp;action=history&quot;)

# Sicherung der Ergebnismenge als .csv unter Angabe von Titel und Tiefe.
usrntwrk.write_csv(&quot;_corona_500&quot;)

# Abruf der letzten 50 Edits für jeden User der abgerufenen Historie in allen definierten Sprachen (self.cont_languages). Zuordnung von Sprachen zu Nutzern gemäß Usercontributions.
usrntwrk.add_usercontributions(&quot;50&quot;)
usrntwrk.compute_language

# Entfernen aller Artikel mit weniger als 5 referenzierten Versionen und Zusammenfassen von gleichartigen Edges (selbe Relation)
usrntwrk.delete_articles_by_count(edgeCount = 5)
usrntwrk.condense_edges()

# Visualisierung der Sprachverteilung mittels Sprachknoten.
usrntwrk.create_language_network()

</code></pre>
<h4 id="def-_get_xml_dataself-url-stylesheet">def _get_xml_data<code>(self, url, stylesheet)</code></h4>
<p>Ruft eine Seite ab und transformiert diese nach XML.</p>
<pre><code class="language-python"># url:          parametrisierte URL der Artikelhistorie oder User contributions
# stylesheet:   xslt zur Transformation der abzurufenden Daten
# returns:      etree-Objekt mit XML

datadir = &quot;data/&quot;
lang = urlparse(url).netloc.split(&quot;.&quot;)[0] + &quot;_&quot;

# Dateiname wird aus Query-Teil der URL und Endung .xml gebildet
if urlparse(url).query:
    file = urlparse(url).query + &quot;.xml&quot;

# Falls kein Queryteil vorhanden, letzter Pfadteil +.xml
else:
    file = str(urlparse(url).path.rsplit(&quot;/&quot;)[-1]) + &quot;.xml&quot;

# vollständiger Pfad aus Verzeichnis/Sprachversion_Dateiname.xml
file = datadir + lang + file

# Wenn XML bereits vorhanden, die verwenden
if os.path.exists(file):
    xml = etree.parse(open(file, &quot;r&quot;))

# HTML abrufen, mittels Schema transformieren und lokal speichern
else:
    html = requests.get(url).content
    tree = etree.fromstring(html, parser = etree.XMLParser(recover=True))
    xml = etree.XSLT(etree.parse(stylesheet))(tree)
    with open(file, &quot;w&quot;) as f:
        f.write(str(xml))

return xml
</code></pre>
<h4 id="def-add_article_dataself-url">def add_article_data<code>(self, url)</code></h4>
<p>Lädt eine via URL definierte Artikelhistorie der Wikipedia herunter oder lädt ein lokales Abbild und trägt den Artikel sowie die zugehörigen Benutzer in <code>nodes[]</code> und <code>edges[]</code> ein.</p>
<pre><code class="language-python"># url:  Parametrisierte URL der Artikelhistorie in der Form: https://en.wikipedia.org/w/index.php?title=TITLE&amp;limit=LIMIT&amp;action=history

# article XML beziehen bzw. lokale Kopie laden
article = self._get_xml_data(url, &quot;history.xsl&quot;)

# article Sprache ermitteln
article_lang = article.xpath('/article/language')[0].text

# article-node zusammenstellen
article_node = self.nodes_append(article.xpath('/article/title')[0].text.rsplit(&quot;: &quot;, 1)[0], 'article', article_lang, 1)

for version in article.xpath('/article/versions/version'):
    user_node = self.nodes_append(version.xpath('./user')[0].text, 'user', '')

    # version als edge hinzufügen
    self.edges_append(user_node[0],
        article_node[0],
        version.xpath('./timestamp')[0].text,
        version.xpath('./id',)[0].text,
        article_lang)
</code></pre>
<h4 id="def-compute_languageself">def compute_language<code>(self)</code></h4>
<p>Ermittelt über die User Contributions die Sprachen und deren absolute Häufigkeit je User.</p>
<pre><code class="language-python"># NB: Vor condense_edges() und delete_nodes_by_count() ausführen.

# aus nodes[] _alle_ Artikel und deren Sprache (z.B. {&quot;en&quot;:1}) auflisten
articles = [[name, lang] for [name, lang, type] in self.nodes if type == 'article']
for node in self.nodes:
    if node[2] == 'user':

        # alle Artikel-User-Relationen für den aktuellen User aus edges[]
        edits = [article for [user, article, timestamp, vid, lang] in self.edges if user == node[0]]

        # für die ermittelten Artikel die Sprache{} ermitteln
        # languages ist also: [{},]
        languages = [lang for [name, lang] in articles if name in edits]

        # node[1] = Sprachen, sollte bei einem User ein leeres dict sein
        if type(node[1]) != type(dict()):
            node[1] = dict()

        # für jedes {} in languages wird dessen wert
        for item in languages:

            # je item wird jeder bekannte Sprachkey geprüft
            for lang in self._cont_languages.keys():

            # je Sprachkey wird der Wert aus item abgerufen und im node aufaddiert
                if lang in node[1].keys():
                    node[1][lang] += item.get(lang, 0)
                else:
                    node[1].update({lang: item.get(lang, 0)})
</code></pre>
<h4 id="def-add_usercontributionsself-depth-100-offset-users-none">def add_usercontributions<code>(self, depth = "100", offset = "", users = None)</code></h4>
<p>Fügt für alle User des aktuellen Netzwerkes für alle definierten Sprachen (<code>self._cont_languages</code>) die User-Contributions als Nodes hinzu und verknüpft diese mit dem User. Dient der Ermittlung der User-Sprachen über die Contributions und zur Sichtbarmachung eventueller Contributionnetzwerke.</p>
<pre><code class="language-python"># depth:    Int. Default = 100. Anzahl an Einträgen je Contribution die geladen werden soll.
# offset:   Str. Datum im Format YYYYMMDDhhmmss. Zeitpunkt ab dem antichronologisch die Contributions ermittelt werden.
# Users:    List. Default = None. Ermittelt die Contributions für die direkt als Liste übergebenen User. Die lokale nodes[] wird hierbei ignoriert.

# wenn Users nicht gesetzt ist -&gt; vorhandene User ermitteln
if users is None or len(users) == 0:
    users = [name for [name, lang, nodetype] in self._nodes if nodetype == &quot;user&quot;]

    # (falsche) Stringeingaben abfangen und in Liste umwandeln
    if isinstance(users, str) and len(users) &gt; 0:
        users = [users]

    for user in users:
        print(&quot;ermittle Artikel für User &quot; + user + &quot; ..&quot;)
        for cont in self._cont_languages.items():

            # je Sprachversion, NB &amp;target=USERNAME muss als letztes Element notiert sein
            self.add_user_data(cont[1] + '&amp;offset=' + str(offset) + '&amp;limit=' + str(depth) + '&amp;target=' + user)
</code></pre>
<h4 id="def-delete_nodes_by_countself-edgecount-2-user-false">def delete_nodes_by_count<code>(self, edgeCount = 2, user = False)</code></h4>
<p>Entfernt sämtliche Article-Nodes mit weniger als n Versionen gesamt (<code>edgeCount</code>). Optional werden auch Usernodes entfernt (<code>user</code>).</p>
<pre><code class="language-python"># edgeCount:    Anzahl an Versionen (edges) unter der ein Artikel gelöscht wird. Optional, default = 2
# user:         Bool. Default = False. Wenn gesetzt, werden User analog zu Artikeln entfernt.

# NB: Vor condense_edges() ausführen.

# lokale Kopie zur Manipulation
nodes_reduced = self.nodes.copy()
for item in self.nodes:
    mentions = None

    if user and item[2] == 'user':
        # Referenzen für User ermitteln
        mentions = [article for [user, article, timestamp, vid, lang] in self.edges if user == item[0]]

    elif item[2] == 'article':
        # Referenzen für Artikel ermitteln
        mentions = [user for [user, article, timestamp, vid, lang] in self.edges if article == item[0]]

    # Wenn Referenzen &lt; Parameter, Item löschen
    if mentions is not None and len(set(mentions)) &lt; edgeCount:
        nodes_reduced.remove(item)

# reduzierte Liste übergeben (an private, da setter appended)
self._nodes = nodes_reduced.copy()
</code></pre>
<h4 id="def-return_intervalself-begin-end">def return_interval<code>(self, begin, end)</code></h4>
<p>Vergleicht die Timestamps in <code>edges[]</code> mit den übergebenen Grenzwerten und gibt ein (<code>nodes[]</code>, <code>edges[]</code>) tuple für den gegebenen Zeitraum zurück. Relationen zu den nachträglich erzeugten Sprach-Nodes werden immer übernommen, sind also interval-unabhängig.</p>
<pre><code class="language-python"># begin:                Datetime. &lt;= Intervall.
# end:                  Datetime. &gt;= Intervall.
# Parametersignatur:    datetime(YYYY, M, D, h, m)
# returns:              tuple(nodes[], edges[])

nodes_slice = list()
edges_slice = list()

# Edges der Sprachrelationen ermitteln -&gt; die haben keine Timestamps
lang_edges = [[user, language, timestamp, vid, lang]
                for [user, language, timestamp, vid, lang]
                in self._edges if language in self._cont_languages.keys()]

# Edges über timestamp ermitteln. Edges: [user, article, timestamp, id, lang]
# oder condensed: [user, article, [timestamp], [id], lang]

for edge in self._edges:
# Sprach-Relationen haben kein Timestamp und müssen gesondert behandelt werden
    if edge not in lang_edges:
        try:
            # liste -&gt; also condensed -&gt; auf Listeneinträge prüfen
            if type(edge[2]) == type(list()):
                timestamps = [timestamp for timestamp in edge[2] 
                    if timestamp &gt;= begin and timestamp &lt;= end]
                if len(timestamps) &gt; 0:
                    # add this edge
                    edges_slice.append(edge)
            # keine Liste -&gt; nicht condensed -&gt; datetime()
            else:
                if edge[2] &gt;= begin and edge[2] &lt;= end:
                    edges_slice.append(edge)
        except TypeError:
            print(&quot;Wrong timestamp type: &quot; + str(edge))

# alle adressierten Nodes (user &amp; article) ermitteln und unnötige Duplikate entfernen
users_in_edges = set([user for [user, article, timestamp, vid, lang]
                    in edges_slice])
articles_in_edges = set([article for [user, article, timestamp, vid, lang] 
                    in edges_slice])

# Sprachrelationen für User hinzufügen
edges_slice += [[user, language, timestamp, vid, lang]
                for [user, language, timestamp, vid, lang]
                in lang_edges if user in users_in_edges]

# alle Nodes übernehmen, die in edges_slice oder _cont_languages referenziert werden
nodes_slice = [[name, lang, ntype]
    for [name, lang, ntype]
    in self._nodes
    if name in users_in_edges
    or name in articles_in_edges
    or name in self._cont_languages.keys()]

return (nodes_slice, edges_slice)
</code></pre>
<h2 id="xslt-schemata">XSLT-SCHEMATA</h2>
<p>Die folgenden Schema-Auszüge zeigen die verwendeten Transformationsschemata zur Auswertung der HTML-Dateien. Der Quelltext entspricht XSLT in der Version 1.0. Die Auszüge beschränken sich auf die Funktionslogik.</p>
<h3 id="historyxsl">history.xsl</h3>
<p>Die Schemadatei dient dazu, das HTML-Dokument einer Wikipedia-Versionsgeschichte zu zerlegen und in eine auswertbare Struktur zu überführen.</p>
<pre><code class="language-xslt">&lt;xsl:variable name=&quot;lang&quot; select=&quot;//@lang&quot; /&gt;

&lt;xsl:template match=&quot;/&quot;&gt;
    &lt;article&gt;
        &lt;language&gt;&lt;xsl:value-of select=&quot;$lang&quot;/&gt;&lt;/language&gt;
        &lt;xsl:apply-templates /&gt;
    &lt;/article&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='title'&gt;
    &lt;title&gt;
        &lt;xsl:value-of select='.'/&gt;
    &lt;/title&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='ul[@id=&quot;pagehistory&quot;]'&gt;
    &lt;versions&gt;
        &lt;xsl:for-each select=&quot;li&quot;&gt;
            &lt;version&gt;
                &lt;id&gt;&lt;xsl:value-of select=&quot;@data-mw-revid&quot;/&gt;&lt;/id&gt;
                &lt;timestamp&gt;
                    &lt;xsl:value-of select='*[@class=&quot;mw-changeslist-date&quot;]' /&gt;
                &lt;/timestamp&gt;
                &lt;user&gt;
                    &lt;xsl:value-of select=&quot;.//bdi&quot;/&gt;
                &lt;/user&gt;
                &lt;minoredit&gt;
                    &lt;xsl:choose&gt;
                        &lt;xsl:when test='.//@class=&quot;minoredit&quot;'&gt;1&lt;/xsl:when&gt;
                        &lt;xsl:otherwise&gt;0&lt;/xsl:otherwise&gt;
                    &lt;/xsl:choose&gt;
                &lt;/minoredit&gt;
                &lt;comment&gt;
                    &lt;xsl:value-of select='*[@class=&quot;comment comment--without-parentheses&quot;]'/&gt;
                &lt;/comment&gt;
           &lt;/version&gt;
        &lt;/xsl:for-each&gt;
    &lt;/versions&gt;
&lt;/xsl:template&gt;
</code></pre>
<h3 id="userxsl">user.xsl</h3>
<p>Diese Schemadatei dient dazu, das HTML-Dokument einer Wikipedia-Benutzerbeiträgeseite zu zerlegen und in eine auswertbare Struktur zu überführen.</p>
<pre><code class="language-xslt">&lt;xsl:variable name=&quot;lang&quot; select=&quot;//@lang&quot; /&gt;

&lt;xsl:template match=&quot;/&quot;&gt;
    &lt;user&gt;
        &lt;language&gt;&lt;xsl:value-of select=&quot;$lang&quot;/&gt;&lt;/language&gt;
        &lt;xsl:apply-templates /&gt;
    &lt;/user&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='link[@rel=&quot;canonical&quot;]'&gt;
    &lt;name&gt;
        &lt;xsl:value-of select='substring-after(@href, &quot;target=&quot;)'/&gt;
    &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match='ul[@class=&quot;mw-contributions-list&quot;]'&gt;
    &lt;versions&gt;
        &lt;xsl:for-each select=&quot;li&quot;&gt;
            &lt;version&gt;
                &lt;id&gt;&lt;xsl:value-of select=&quot;@data-mw-revid&quot;/&gt;&lt;/id&gt;
                &lt;timestamp&gt;
                    &lt;xsl:value-of select='*[@class=&quot;mw-changeslist-date&quot;]' /&gt;
                &lt;/timestamp&gt;
                &lt;title&gt;
                    &lt;xsl:value-of select=&quot;a/@title&quot;/&gt;
                &lt;/title&gt;
                &lt;comment&gt;
                    &lt;xsl:value-of select='*[@class=&quot;autocomment&quot;]'/&gt;
                &lt;/comment&gt;
            &lt;/version&gt;
        &lt;/xsl:for-each&gt;
    &lt;/versions&gt;
&lt;/xsl:template&gt;
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.b8dbb3d2.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.081f42fc.min.js"></script>
      
    
  </body>
</html>